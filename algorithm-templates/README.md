# 📚 알고리즘 템플릿 라이브러리

코딩테스트 준비를 위한 핵심 알고리즘 템플릿 모음입니다.
백준 온라인저지에서 해결한 62개의 문제를 분석하여 자주 사용되는 알고리즘 패턴을 정리했습니다.

---

## 📋 목차

1. [Union-Find (분리 집합)](#1-union-find)
2. [BFS (너비 우선 탐색)](#2-bfs)
3. [Dijkstra (최단 경로)](#3-dijkstra)
4. [위상 정렬](#4-topological-sort)
5. [Dynamic Programming](#5-dynamic-programming)
6. [DFS (깊이 우선 탐색)](#6-dfs)
7. [Two Pointer (투 포인터)](#7-two-pointer)
8. [Binary Search (이분 탐색)](#8-binary-search)
9. [MST (최소 스패닝 트리)](#9-mst)

---

## 1. Union-Find

**파일:** `UnionFind.java`

### 사용 사례
- 크루스칼 알고리즘 (MST)
- 연결 요소 찾기
- 사이클 검사

### 시간복잡도
O(α(N)) ≈ O(1) (경로 압축 + 랭크 최적화)

### 핵심 함수
```java
static int find(int x)              // x의 루트 찾기 (경로 압축)
static boolean union(int x, int y)  // 두 집합 합치기
```

### 참고 문제
- BOJ 1647 - 도시 분할 계획
- BOJ 10775 - 공항
- BOJ 1774 - 우주신과의 교감

---

## 2. BFS

**파일:** `BFS.java`

### 사용 사례
- 최단 거리 찾기 (가중치가 모두 1)
- 레벨별 탐색
- 미로 찾기

### 시간복잡도
O(V + E)

### 주요 패턴
- 기본 BFS (2D 그리드, 그래프)
- 멀티 소스 BFS
- 0-1 BFS

### 참고 문제
- BOJ 16236 - 아기 상어
- BOJ 16928 - 뱀과 사다리 게임
- BOJ 2252 - 줄 세우기

---

## 3. Dijkstra

**파일:** `Dijkstra.java`

### 사용 사례
- 음수 가중치가 없는 그래프에서 최단 경로
- 한 정점에서 다른 모든 정점까지의 최단 거리

### 시간복잡도
O((V + E) log V)

### 핵심 코드
```java
PriorityQueue<Edge> pq = new PriorityQueue<>();
int[] dist = new int[n + 1];
Arrays.fill(dist, Integer.MAX_VALUE);
```

### 참고 문제
- BOJ 1916 - 최소비용 구하기
- BOJ 1504 - 특정한 최단 경로
- BOJ 14938 - 서강그라운드

---

## 4. Topological Sort

**파일:** `TopologicalSort.java`

### 사용 사례
- 선수 과목 순서 정하기
- 작업 순서 스케줄링
- 사이클 검사

### 시간복잡도
O(V + E)

### 주요 패턴
- Kahn's Algorithm (BFS)
- 우선순위 고려 (PriorityQueue)
- 위상 정렬 + DP

### 참고 문제
- BOJ 2252 - 줄 세우기
- BOJ 1766 - 문제집
- BOJ 1005 - ACM Craft

---

## 5. Dynamic Programming

**파일:** `DynamicProgramming.java`

### 사용 사례
- 최적화 문제
- 경우의 수 세기
- 부분 문제의 중복 계산 제거

### 주요 패턴
- 1차원 DP (피보나치, LIS, 최대 부분 합)
- 2차원 DP (배낭 문제, LCS, 편집 거리)
- 구간 DP, 비트마스크 DP
- 역방향 DP

### 참고 문제
- BOJ 14501 - 퇴사
- BOJ 9084 - 동전
- BOJ 15989 - 1, 2, 3 더하기 4
- BOJ 7579 - 앱

---

## 6. DFS

**파일:** `DFS.java`

### 사용 사례
- 경로 탐색
- 사이클 검사
- 백트래킹
- 연결 요소 찾기

### 시간복잡도
O(V + E)

### 주요 패턴
- 기본 DFS (재귀, 스택)
- 사이클 검사 (무방향/방향 그래프)
- 함수형 그래프에서 사이클 찾기
- 백트래킹 (N-Queen, 순열, 조합)

### 참고 문제
- BOJ 9466 - 텀 프로젝트
- BOJ 16724 - 피리 부는 사나이

---

## 7. Two Pointer

**파일:** `TwoPointer.java`

### 사용 사례
- 구간 합 문제
- 특정 조건을 만족하는 부분 배열 찾기
- 슬라이딩 윈도우

### 시간복잡도
O(N)

### 주요 패턴
- 최소/최대 길이 부분 배열
- 합이 특정 값인 구간 찾기
- K개의 서로 다른 원소

### 참고 문제
- BOJ 1806 - 부분합
- BOJ 30804 - 과일 탕후루
- BOJ 2003 - 수들의 합 2

---

## 8. Binary Search

**파일:** `BinarySearch.java`

### 사용 사례
- 정렬된 배열에서 특정 값 찾기
- 최적값 찾기 (Parametric Search)
- Lower Bound / Upper Bound

### 시간복잡도
O(log N)

### 주요 패턴
- 기본 이분 탐색
- Lower/Upper Bound
- Parametric Search (최댓값의 최솟값)
- 실수 이분 탐색
- 삼분 탐색 (Ternary Search)

### 참고 문제
- BOJ 14786 - Ax+Bsin(x)=C ②
- BOJ 1654 - 랜선 자르기
- BOJ 2805 - 나무 자르기

---

## 9. MST

**파일:** `MST.java`

### 사용 사례
- 모든 노드를 연결하는 최소 비용 찾기
- 네트워크 설계 문제

### 알고리즘
- **Kruskal**: 간선 중심, Union-Find 사용, O(E log E)
- **Prim**: 정점 중심, PriorityQueue 사용, O(E log V)

### 주요 패턴
- 기본 MST
- 최대 비용 간선 제외
- 좌표 평면에서 MST
- 일부 간선이 이미 연결된 경우

### 참고 문제
- BOJ 1647 - 도시 분할 계획
- BOJ 1774 - 우주신과의 교감
- BOJ 4386 - 별자리 만들기

---

## 📊 알고리즘 사용 빈도 (분석 기준: 62개 문제)

| 순위 | 알고리즘 | 사용 문제 수 | 비율 |
|:---:|:---------|:-----------:|:----:|
| 1 | BFS | 19 | 31% |
| 2 | Dynamic Programming | 16 | 26% |
| 3 | Topological Sort | 16 | 26% |
| 4 | Graph | 15 | 25% |
| 5 | Union-Find | 8 | 13% |
| 6 | DFS | 8 | 13% |
| 7 | Dijkstra | 8 | 13% |
| 8 | MST | 3 | 5% |

---

## 🎯 사용 방법

### 1. 필요한 템플릿 찾기
문제를 읽고 어떤 알고리즘이 필요한지 파악합니다.

### 2. 템플릿 복사
해당 Java 파일을 열어 필요한 함수를 복사합니다.

### 3. 문제에 맞게 수정
- 입력 형식에 맞게 수정
- 필요한 부분만 선택적으로 사용
- 주석을 참고하여 커스터마이징

### 4. 테스트
예제 입력으로 테스트 후 제출합니다.

---

## 💡 코딩 스타일 특징

이 템플릿들은 다음과 같은 스타일을 따릅니다:

1. **정적 메서드**: 모든 메서드가 `static`으로 선언
2. **빠른 입력**: `BufferedReader` + `StringTokenizer`
3. **명확한 변수명**: 의미를 알기 쉬운 이름 사용
4. **한글 주석**: 이해하기 쉽도록 한글로 설명

---

## 📖 추가 학습 자료

### 다음 단계 추천
- **그래프 고급**: SCC (강한 연결 요소), LCA (최소 공통 조상)
- **고급 DP**: 구간 DP, 비트마스크 DP, 트리 DP
- **자료구조**: Segment Tree, Fenwick Tree
- **문자열**: KMP, Trie, Suffix Array

### 연습 방법
1. 각 알고리즘별로 3-5문제씩 추가 연습
2. 비슷한 유형의 문제를 반복 학습
3. 시간 제한 내에 풀기 연습
4. 예외 케이스 고려하기

---

## 📝 라이선스

이 템플릿들은 자유롭게 사용, 수정, 배포할 수 있습니다.

---

## ✨ 마지막으로

> **"알고리즘은 이해가 아니라 체화입니다."**
>
> 템플릿을 외우는 것보다, 문제를 풀면서 언제 어떤 알고리즘을 사용해야 하는지 감을 익히는 것이 중요합니다.

**Happy Coding! 🚀**
